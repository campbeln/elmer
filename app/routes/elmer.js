//##################################################
//#
//#           ** DO NOT EDIT THIS FILE **
//#
//##################################################
//# Version: 2025-03-27
'use strict';


//# Set the .exports to the Elmer route function definition
module.exports = function($elmer, $router /*, $baseRouter */) {
    //# Setup the required .app.data.proxy variables
    $elmer.app.data.proxy = [];
    $elmer.app.data.proxy.disallowed = ["", "login", "elmer"];

    //#
    $elmer.app.data.response = {};


    //# /elmer/proxy route to allow the registration of Child APIs
    $router.post("/proxy", async (oRequest, oResponse) => {
        let fnLoginRouter,
            oBody = $elmer.type.obj.mk(oRequest.body),
            sRouteName = $elmer.type.str.mk(oBody.route).toLowerCase(),
            oRoute = $elmer.type.query($elmer.app.data.proxy, { route: sRouteName }, { firstEntryOnly: true }),
            oConfig = $elmer.type.obj.mk(oBody.config),
            bSecure = $elmer.type.obj.is(oConfig.security, true) && $elmer.type.str.is(oConfig.security.mode, true),
            bSuccess = false
        ;

        //#
        //oBody.server = ($elmer.io.net.ip.is(oBody.server) ? oBody.server : "0.0.0.0") || "0.0.0.0";

        //# If an existing oRoute was found above
        if ($elmer.type.obj.is(oRoute)) {
            //# If we are to .force the registration over the existing oRoute, flip bSuccess and reset the values within oRoute
            if ($elmer.type.bool.mk(oBody.force, false) /* oBody.force === oRoute.id */) {
                bSuccess = true;
                //oRoute.route = oRoute.route;
                oRoute.secure = bSecure;
                oRoute.config = oConfig;
                //router: oRoute.router,
                oRoute.server = oBody.server;
                oRoute.port = oBody.port;
                oRoute.instance++;
                //oRoute.id = $elmer.type.uuid();
            }
        }
        //# Else if the sRouteName is not within the .disallowed list, flip bSuccess and setup our new oRoute
        else if ($elmer.app.data.proxy.disallowed.indexOf(sRouteName) === -1) {
            bSuccess = true;
            oRoute = {
                route: sRouteName,
                secure: bSecure,
                config: oConfig,
                //router: undefined,
                server: oBody.server,
                port: oBody.port,
                instance: 1,
                id: $elmer.type.uuid()
            };
        }

        //# If the oRoute was bSuccess(fully) set above, .register it
        if (bSuccess) {
            //# .extend our oRoute based on the results of the .register(ation)
            oRoute = $elmer.extend(
                oRoute,
                $elmer.app.services.web.router.register(
                    sRouteName,
                    oRoute.server + ":" + oRoute.port,
                    oConfig
                )
            );

            //# If this proxy oRoute is bSecure
            if (bSecure) {
                //# .resolve the .loginRouter for the current .security.mode (if any)
                //#     NOTE: Due to the bSecure test above, we know that .security.mode .is a .str so it's safe to .trim().toLowerCase() it
                fnLoginRouter = $elmer.resolve($elmer.app.services.security, oConfig.security.mode.trim().toLowerCase() + ".loginRouter");

                //# If there's .loginRouter function for our .mode, .register them
                if ($elmer.type.fn.is(fnLoginRouter)) {
                    $elmer.app.services.web.router.register(
                        sRouteName + "/login",
                        fnLoginRouter()
                        //, {}
                    );
                }
            }
        }

        oResponse.status(bSuccess ? $elmer.io.net.status.success.ok : $elmer.io.net.status.clientError.conflict).json(oRoute);
    });


    //#
    $router.post('/response', async (oRequest, oResponse) => {
        let iStart = Date.now(),
            sID
        ;

        //# Ensure that we generate a new sID
        do {
            sID = $elmer.type.uuid();
        } while ($elmer.app.data.response[sID]);

        //#
        $elmer.app.data.response[sID] = {
            data: oRequest.body.data,
            start: iStart,
            updated: iStart,
            done: (oRequest.body.done === true ? $elmer.type.date.ydhms(iStart) : ""),
            cancel: false,
            cancelled: false
        };

        oResponse.status(200).json({
            ok: true,
            id: sID,
            cancel: false
        });
    });


    //#
    $router.post('/response/:id', async (oRequest, oResponse) => {
        let sID = oRequest.params.id,
            bOk = (sID in $elmer.app.data.response),
            iNow = Date.now()
        ;

        //#
        $elmer.extend($elmer.app.data.response[sID], {
            data: oRequest.body.data,
            updated: iNow,
            done: (oRequest.body.done === true ? $elmer.type.date.ydhms($elmer.app.data.response[sID].start, iNow) : ""),
            cancelled: (oRequest.body.cancelled === true)
        });

        oResponse.status(bOk ? 200 : 404).json(
            $elmer.extend({}, $elmer.app.data.response[sID], {
                ok: bOk,
                id: sID
            })
        );
    });


    //#
    $router.get('/response/:id', async (oRequest, oResponse) => {
        let sID = oRequest.params.id,
            bOk = (sID in $elmer.app.data.response)
        ;

        oResponse.status(bOk ? 200 : 404).json(
            $elmer.extend({}, $elmer.app.data.response[sID], {
                ok: bOk,
                id: sID
            })
        );

        //#
        if ($elmer.type.bool.mk(oRequest.querystring.delete, false)) {
            delete $elmer.app.data.response[sID];
        }

        //#
        if ($elmer.type.bool.mk(oRequest.querystring.cancel, false)) {
            $elmer.app.data.response[sID].cancel = true;
        }
    });



    //#
    $router.get('/cache/id/:id', async (oRequest, oResponse) => {
        let sID = oRequest.params.id,
            a_oData = $elmer.type.query($elmer.app.cache, { trace: { id: sID } }),
            iStatus = ($elmer.type.arr.is(a_oData, true) ? 200 : 404)
        ;

        oResponse.status(iStatus).json({
            id: sID,
            data: a_oData
        });
    });


    //#
    $router.get('/cache/clear/id/:id', async (oRequest, oResponse) => {
        let sID = oRequest.params.id,
            iStatus = ($elmer.type.obj.is($elmer.resolve($elmer.app.cache, sID)) ? 200 : 404),
            bCleared = (iStatus === 200)
        ;

        //#
        if (bCleared) {
            delete $elmer.app.cache[sID];
        }

        oResponse.status(iStatus).json({
            id: sID,
            cleared: bCleared
        });
    });


    //#
    $router.get('/cache/route/:route', async (oRequest, oResponse) => {
        let sRoute = oRequest.params.route,
            a_oData = $elmer.type.query($elmer.app.cache, { route: sRoute }),
            iStatus = ($elmer.type.arr.is(a_oData, true) ? 200 : 404)
        ;

        oResponse.status(iStatus).json({
            route: sRoute,
            data: a_oData
        });
    });


    //# TODO: Check :subroute value
    $router.get('/cache/route/:route/:subroute', async (oRequest, oResponse) => {
        let sRoute = oRequest.params.route,
            sSubroute = oRequest.params.subroute,
            a_oData = $elmer.type.query($elmer.app.cache, { route: sRoute, subroute: sSubroute }),
            iStatus = ($elmer.type.arr.is(a_oData, true) ? 200 : 404)
        ;

        oResponse.status(iStatus).json({
            route: sRoute,
            subroute: sSubroute,
            data: a_oData
        });
    });


    //#
    $router.get('/cache/clear/route/:route', async (oRequest, oResponse) => {
        let i,
            sRoute = oRequest.params.route,
            a_oData = $elmer.type.query($elmer.app.cache, { route: sRoute }),
            iStatus = ($elmer.type.arr.is(a_oData, true) ? 200 : 404),
            bCleared = (iStatus === 200)
        ;

        //#
        if (bCleared) {
            for (i = 0; i < a_oData.length; i++) {
                delete $elmer.app.cache[a_oData[i].trace.id];
            }
        }

        oResponse.status(iStatus).json({
            route: sRoute,
            cleared: (iStatus === 200)
        });
    });


    //#
    $router.get('/cache/clear/route/:route/:subroute', async (oRequest, oResponse) => {
        let i,
            sRoute = oRequest.params.route,
            sSubroute = oRequest.params.subroute,
            a_oData = $elmer.type.query($elmer.app.cache, { route: sRoute, subroute: sSubroute }),
            iStatus = ($elmer.type.arr.is(a_oData, true) ? 200 : 404),
            bCleared = (iStatus === 200)
        ;

        //#
        if (bCleared) {
            for (i = 0; i < a_oData.length; i++) {
                delete $elmer.app.cache[a_oData[i].trace.id];
            }
        }

        oResponse.status(iStatus).json({
            route: sRoute,
            cleared: (iStatus === 200)
        });
    });


    //#
    $router.get('/cache/clear/before/:before', async (oRequest, oResponse) => {
        let i, dCurrentWhen,
            sRoute = oRequest.params.route,
            sSubroute = oRequest.params.subroute,
            dBefore = $elmer.type.date.mk(oRequest.querystring.before, null),
            a_oSubroute = $elmer.resolve($elmer, ["cache", sRoute, sSubroute]),
            iStatus = ($elmer.type.arr.is(a_oSubroute) ? 200 : 404)
        ;

        //# If we found our sRoute/sSubroute
        if (iStatus === 200) {
            //# If the caller passed in a dBefore cutoff date on the .querystring, traverse our a_oSubroute while .resolve'ing the dCurrentWhen as we go
            for (i = 0; i < a_oSubroute.length; i++) {
                dCurrentWhen = $elmer.type.date.mk($elmer.resolve(a_oSubroute[i], "when"), null);

                //# If the dCurrentWhen is dBefore our cutoff date, .splice it out of our a_oSubroute
                if (dCurrentWhen && $elmer.type.date.cmp(dCurrentWhen, dBefore) < 0) {
                    a_oSubroute.splice(i, 1);
                }
                //# TODO: neek
                //# Else we are to clear the entire sSubroute
                else {
                    delete $elmer.cache[sRoute][sSubroute];
                }
            }
        }

        oResponse.status(iStatus).json({
            route: sRoute,
            subroute: sSubroute,
            cleared: (iStatus === 200)
        });
    });


}; //# module.exports
