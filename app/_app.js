//##################################################
//#
//#           ** DO NOT EDIT THIS FILE **
//#
//##################################################
//# Version: 2023-08-31
'use strict';

const $formidable = require('formidable');
const $fs = require('fs');
const $ip = require('ip');
const $jszip = require('jszip');


module.exports = async function ($elmer, $express, $httpServer) {
    $elmer.app = {
        version: "0.2.2023-04-04",

        data: {},
        status: {},
        config: {
            //# Remove `node index.js` from process.argv (NOTE: ignores any flags sent to `node`)
            args: process.argv.slice(2)
        },

        services: { //# collection of external services
            security: {
                //jwt: {},
                //basic: {}
            }, //# $elmer.app.services.security

            web: {
                //url: $url,
                multipartForm: function (oRequest, fnOnComplete, oOptions) {
                    let $form,
                        oFormData = {
                            formidable: null,
                            fields: {},
                            files: {}
                        },
                        iMB = (1024 * 1024)
                    ;

                    //#
                    oOptions = $elmer.extend({
                        fileSizeMb: $elmer.app.config.uploadLimitMb,
                        multiples: true,
                        uploadDir: __dirname + '/uploads/',
                        readFileSync: {
                            encoding: "utf8",
                            flag:'r'
                        }
                    }, oOptions);

                    //#
                    $form = new $formidable.IncomingForm({
                        maxFileSize: oOptions.fileSizeMb * iMB,
                        multiples: oOptions.multiples,
                        uploadDir: oOptions.uploadDir
                    });
                    oFormData.formidable = $form;


                    //# Since $form.on('end'); is called more than once on occasion, wrap the passed fnOnComplete to ensure it's only called .once
                    fnOnComplete = $elmer.type.fn.once(fnOnComplete);

                    //# Setup the event listeners then .parse the oRequest
                    $form.on('field', function(sField, sValue) {
                        //# If the sField already exists within oFormData.fields, make sure it's an .arr and .push in the additional sValue
                        if ($elmer.type.obj.has(oFormData.fields, sField)) {
                            oFormData.fields[sField] = $elmer.type.arr.mk(oFormData.fields[sField], [ oFormData.fields[sField] ]);
                            oFormData.fields[sField].push(sValue);
                        }
                        //# Else this is the first instance of the sField, so set it in oFormData.fields
                        else {
                            oFormData.fields[sField] = sValue;
                        }
                    });
                    $form.on('file', function(sField, oFile) {
                        //# If the sField already exists within oFormData.fields, make sure it's an .arr and .push in the additional sValue
                        if ($elmer.type.obj.has(oFormData.files, sField)) {
                            oFormData.files[sField] = $elmer.type.arr.mk(oFormData.files[sField], [ oFormData.files[sField] ]);
                            oFormData.files[sField].push({
                                file: oFile,
                                getContent: function () {
                                    return $fs.readFileSync(oFile.filepath, oOptions.readFileSync);
                                }
                            });
                        }
                        //# Else this is the first instance of the sField, so set it in oFormData.fields
                        else {
                            oFormData.files[sField] = {
                                file: oFile,
                                getContent: function () {
                                    return $fs.readFileSync(oFile.filepath, oOptions.readFileSync);
                                }
                            };
                        }
                    });
                    $form.on('end', function() {
                        $elmer.type.fn.run(fnOnComplete, { args: [ oFormData ] });
                    });
                    $form.on('error', function(err) {
console.log("error!!", err);
                    });

                    $form.parse(oRequest);

                    /*$form.parse(oRequest, function (err, fields, files) {
                        if (err) throw err;
                        $elmer.type.fn.run(fnOnComplete, { args: [oFormData] });

                        var oldpath = files.file.path
                        var newpath = 'C:/VSI/' + files.file.name;
                        /*fs.rename(oldpath, newpath, function (err) {
                          if (err) {
                            res.write(JSON.stringify({
                              success: false,
                              message: 'error happend'
                            }));
                            res.end()
                            throw err;
                          }
                  
                          res.write(JSON.stringify({
                            success: true,
                            message: 'Successfully Uploaded'
                          }));

                          res.end();
                        });* /
                      });*/
                },
                express: $express,
                server: $httpServer,
                ip: $ip,
                register: async function () {
                    //# curl -X GET http://localhost:$portLocal/
                    return await $elmer.io.net.get("http://" + $elmer.app.config.name + "." + $elmer.app.config.hostname + ":" + $elmer.app.config.port + "/?register=true");
                },


                router: (function() {
                    let a_oRegisteredRoutes = [];

                    return $elmer.extend(
                        function() {
                            return $express.Router();
                        }, //# services.web.router
                        {
                            register: function(sRoute, $router, oConfig) {
                                let oRoute, bSecure,
                                    bRouteExists = false,
                                    oElmerConfig = $elmer.extend($router.elmer, oConfig)
                                ;

                                //# .extend and $router passed .elmer oConfig object with any passed oConfig (which implicitly returns an object)
                                oConfig = $elmer.extend($router.elmer, oConfig);

                                //# If the sRoute is valid, setup the local oRoute and determine if the bRouteExists
                                if ($elmer.type.str.is(sRoute)) {
                                    oRoute = $elmer.type.query(a_oRegisteredRoutes, { route: sRoute }, { firstEntryOnly: true, caseInsensitive: true });
                                    bRouteExists = $elmer.type.obj.is(oRoute, true);

                                    //# If the bRouteExists
                                    if (!bRouteExists) {
                                        //# Set bSecure based on if the oElmerConfig.secure setting is a recognized security type
                                        bSecure = $elmer.type.str.cmp($elmer.resolve(oElmerConfig, "security.mode"), ['basic', 'jwt']);

                                        //# If this is a bSecure route, determine the .mode and .use the appropriate middleware
                                        if (bSecure) {
                                            switch(oElmerConfig.security.mode.trim().toLowerCase()) {
                                                case "basic": {
                                                    $httpServer.use(
                                                        "/" + sRoute,
                                                        require(__dirname + "/middleware/_basicauth.js")($elmer, oElmerConfig.security)
                                                    );
                                                    break;
                                                }
                                                case "jwt": {
                                                    $httpServer.use(
                                                        "/" + sRoute,
                                                        require(__dirname + "/middleware/_jwt.js")($elmer, oElmerConfig.security)
                                                    );
                                                    break;
                                                }
                                            }
                                        }

                                        //# .use the sRoute/$router then set it's metadata into the a_oRegisteredRoutes
                                        $httpServer.use("/" + sRoute, $router);
                                        oRoute = {
                                            route: sRoute,
                                            secure: bSecure,
                                            config: oElmerConfig,
                                            router: $router
                                        };
                                        a_oRegisteredRoutes.push(oRoute);
                                    }
                                }

                                return $elmer.extend({
                                    created: !bRouteExists
                                }, oRoute);
                            }, //# router.register

                            registered: function(sRoute, bSecure) {
                                let oRoute,
                                    bRouteExists = false
                                ;

                                //#
                                if ($elmer.type.str.is(sRoute)) {
                                    oRoute = $elmer.type.query(a_oRegisteredRoutes, { route: sRoute }, { firstEntryOnly: true, caseInsensitive: true });
                                    bRouteExists = $elmer.type.obj.is(oRoute, true);
                                }

                                return (bRouteExists &&
                                    (arguments.length === 1 || $elmer.type.bool.mk(bSecure, false) === oRoute.secure)
                                );
                            } //# router.registered
                        }
                    );
                }()), //# $elmer.app.services.web.router


                //# Determines if the vAPIName(s) heartbeat endpoint are up and running
                apiUp: async function (vAPIName) {
                    let oAPIResponse, i,
                        a_sAPINames = $elmer.type.arr.mk(vAPIName, [vAPIName]),
                        oReturnVal = {
                            ok: true,
                            responses: []
                        }
                    ;

                    //#
                    for (i = 0; i < a_sAPINames.length; i++) {
                        //#
                        oAPIResponse = await $elmer.io.net.get(
                            "http://" + a_sAPINames[i] + "." + $elmer.app.config.hostname + ":" + $elmer.app.config.port + "/"
                        );
                        oReturnVal.responses.push(oAPIResponse);

                        //#
                        oReturnVal.ok = (oReturnVal.ok &&
                            oAPIResponse && oAPIResponse.data &&
                            oAPIResponse.ok &&
                            $elmer.type.str.is(oAPIResponse.data.message, true) &&
                            $elmer.type.date.is(oAPIResponse.data.time) // $elmer.type.date.is($elmer.type.date.mk(oAPIResponse.data.time, null))
                        );
                    }

                    return oReturnVal;
                } //# $elmer.app.services.web.apiUp
            }, //# $elmer.app.services.web

            fs: {
                fs: $fs,
                baseDir: __dirname + "/../",

                //#
                zip: function (a_vFiles) {
                    let vCurrent, buffZip, oReturnVal, i,
                        $zip = new $jszip()
                    ;

                    //# If the passed a_vFiles .is an .arr, traverse it pulling each vCurrent file entry as we go
                    if ($elmer.type.arr.is(a_vFiles, true)) {
                        for (i = 0; i < a_vFiles.length; i++) {
                            vCurrent = a_vFiles[i];

                            //# If the vCurrent .file entry .is an .obj
                            if ($elmer.type.obj.is(vCurrent)) {
                                //# If there's a .file
                                if (vCurrent.file) {
                                    $zip.file(vCurrent.filename || 'untitled' + (i + 1) + '.file', vCurrent.file, { base64: (!!vCurrent.true) });
                                }
                                //# Else treat vCurrent as JSON
                                else {
                                    $zip.file('untitled' + (i + 1) + '.json', JSON.stringify(vCurrent));
                                }
                            }
                            //# Else the vCurrent file entry isn't an .obj so treat it as a string
                            else {
                                $zip.file('untitled' + (i + 1) + '.txt', $elmer.type.str.mk(vCurrent));
                            }
                        }

                        //# .generate the $zip file
                        buffZip = $zip.generate({
                            type: "blob",
                            compression: "DEFLATE",
                            compressionOptions: {
                                level: 6
                            }
                        });

                        oReturnVal = {
                            buffer: buffZip,
                            httpResponse: function (oResponse, sSaveAsFilename, iHTTPCode) {
                                oResponse.writeHead($elmer.type.int.mk(iHTTPCode, 200), {
                                    'Content-Type': 'application/zip',
                                    'Content-disposition': 'attachment;filename=' + $elmer.type.str.mk(sSaveAsFilename, "download.zip"),
                                    'Content-Length': buffZip.length
                                });
                                oResponse.end(Buffer.from(buffZip, 'binary'));
                            }
                        };
                        /*
                        fs.writeFile('test1.zip', $zip.generate(options), 'binary', function (error) {
                            console.log('wrote test1.zip', error);
                        });
                        */
                    }

                    return oReturnVal;
                },

                //#
                requireDir: function(sDir, a_sExcludeFiles, fnCallback) {
                    let requireDirRecurse = function (sPath, sDirectory) {
                        $elmer.app.services.fs.fs.readdirSync(sPath).forEach(function(sFile) {
                            let oFS = {
                                file: sFile,
                                dir: sPath + "/",
                                path: sPath + "/" + sFile,
                                url: sDirectory.replace(/^\/routes/i, "") + $elmer.type.str.mk(sFile).replace(/\.js$/i, "")
                            };

                            //#
                            if ($elmer.app.services.fs.fs.lstatSync(oFS.path).isDirectory()) {
                                requireDirRecurse(oFS.path, sFile + "/");
                            }
                            //#
                            else if ($elmer.type.str.is(sFile, true) && a_sExcludeFiles.indexOf(sFile) === -1) {
                                fnCallback(require(oFS.path), oFS);
                                $elmer.app.status.routes.push(oFS);
                            }
                        });
                    }; //# requireDirRecurse

                    //# Setup the .status.routes for use in requireDirRecurse
                    $elmer.app.status.routes = [];

                    //#
                    sDir = $elmer.type.str.mk(sDir);
                    sDir = (sDir[0] !== "/" ? "/" : "") + sDir;
                    a_sExcludeFiles = $elmer.type.arr.mk(a_sExcludeFiles);
                    fnCallback = $elmer.type.fn.mk(fnCallback, function (fnRequiredFile /*, oFS*/) {
                        fnRequiredFile($elmer);
                    });

                    //# Kick off the recursive process
                    requireDirRecurse(__dirname + sDir, sDir);
                } //# $elmer.app.services.fs.requireDir
            } //# $elmer.app.services.fs

        }, //# $elmer.app.services

        log: {
            api: function (oData, oRequest) {
                //# oData = { status, json, error }
            }
        }, //# $elmer.app.log

        error: {
            response: function (oResponse, vErrorMessage, iHTTPCode) {
                let sErrorMessage = ($elmer.type.obj.is(vErrorMessage) ? vErrorMessage.message : vErrorMessage),
                    oDetails = $elmer.resolve(vErrorMessage, "details")
                ;

                oResponse
                    .status($elmer.type.int.mk(iHTTPCode, 500))
                    .json({
                        success: false,
                        error: sErrorMessage || "An unknown error occurred.",
                        details: oDetails
                    })
                ;
            }
        } //# $elmer.app.error
    };
};
